<!DOCTYPE html>
<html data-darkreader-mode="dynamic" data-darkreader-scheme="dark"><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8"><style class="darkreader darkreader--fallback" media="screen"></style><style class="darkreader darkreader--text" media="screen"></style><style class="darkreader darkreader--invert" media="screen">.jfk-bubble.gtx-bubble, .captcheck_answer_label > input + img, span#closed_text > img[src^="https://www.gstatic.com/images/branding/googlelogo"], span[data-href^="https://www.hcaptcha.com/"] > #icon, #bit-notification-bar-iframe, embed[type="application/pdf"] {
    filter: invert(100%) hue-rotate(180deg) contrast(90%) !important;
}</style><style class="darkreader darkreader--inline" media="screen">[data-darkreader-inline-bgcolor] {
  background-color: var(--darkreader-inline-bgcolor) !important;
}
[data-darkreader-inline-bgimage] {
  background-image: var(--darkreader-inline-bgimage) !important;
}
[data-darkreader-inline-border] {
  border-color: var(--darkreader-inline-border) !important;
}
[data-darkreader-inline-border-bottom] {
  border-bottom-color: var(--darkreader-inline-border-bottom) !important;
}
[data-darkreader-inline-border-left] {
  border-left-color: var(--darkreader-inline-border-left) !important;
}
[data-darkreader-inline-border-right] {
  border-right-color: var(--darkreader-inline-border-right) !important;
}
[data-darkreader-inline-border-top] {
  border-top-color: var(--darkreader-inline-border-top) !important;
}
[data-darkreader-inline-boxshadow] {
  box-shadow: var(--darkreader-inline-boxshadow) !important;
}
[data-darkreader-inline-color] {
  color: var(--darkreader-inline-color) !important;
}
[data-darkreader-inline-fill] {
  fill: var(--darkreader-inline-fill) !important;
}
[data-darkreader-inline-stroke] {
  stroke: var(--darkreader-inline-stroke) !important;
}
[data-darkreader-inline-outline] {
  outline-color: var(--darkreader-inline-outline) !important;
}
[data-darkreader-inline-stopcolor] {
  stop-color: var(--darkreader-inline-stopcolor) !important;
}</style><style class="darkreader darkreader--variables" media="screen">:root {
   --darkreader-neutral-background: #131516;
   --darkreader-neutral-text: #d8d4cf;
   --darkreader-selection-background: #004daa;
   --darkreader-selection-text: #e8e6e3;
}</style><style class="darkreader darkreader--root-vars" media="screen"></style><script class="darkreader darkreader--proxy">(function injectProxy() {
        document.dispatchEvent(new CustomEvent('__darkreader__inlineScriptsAllowed'));
        const addRuleDescriptor = Object.getOwnPropertyDescriptor(CSSStyleSheet.prototype, 'addRule');
        const insertRuleDescriptor = Object.getOwnPropertyDescriptor(CSSStyleSheet.prototype, 'insertRule');
        const deleteRuleDescriptor = Object.getOwnPropertyDescriptor(CSSStyleSheet.prototype, 'deleteRule');
        const removeRuleDescriptor = Object.getOwnPropertyDescriptor(CSSStyleSheet.prototype, 'removeRule');
        const shouldWrapDocStyleSheets = location.hostname.endsWith('pushbullet.com');
        const documentStyleSheetsDescriptor = shouldWrapDocStyleSheets ? Object.getOwnPropertyDescriptor(Document.prototype, 'styleSheets') : null;
        const cleanUp = () => {
            Object.defineProperty(CSSStyleSheet.prototype, 'addRule', addRuleDescriptor);
            Object.defineProperty(CSSStyleSheet.prototype, 'insertRule', insertRuleDescriptor);
            Object.defineProperty(CSSStyleSheet.prototype, 'deleteRule', deleteRuleDescriptor);
            Object.defineProperty(CSSStyleSheet.prototype, 'removeRule', removeRuleDescriptor);
            document.removeEventListener('__darkreader__cleanUp', cleanUp);
            document.removeEventListener('__darkreader__addUndefinedResolver', addUndefinedResolver);
            if (shouldWrapDocStyleSheets) {
                Object.defineProperty(Document.prototype, 'styleSheets', documentStyleSheetsDescriptor);
            }
        };
        const addUndefinedResolver = (e) => {
            customElements.whenDefined(e.detail.tag).then(() => {
                document.dispatchEvent(new CustomEvent('__darkreader__isDefined', { detail: { tag: e.detail.tag } }));
            });
        };
        document.addEventListener('__darkreader__cleanUp', cleanUp);
        document.addEventListener('__darkreader__addUndefinedResolver', addUndefinedResolver);
        const updateSheetEvent = new Event('__darkreader__updateSheet');
        function proxyAddRule(selector, style, index) {
            addRuleDescriptor.value.call(this, selector, style, index);
            if (this.ownerNode && !this.ownerNode.classList.contains('darkreader')) {
                this.ownerNode.dispatchEvent(updateSheetEvent);
            }
            return -1;
        }
        function proxyInsertRule(rule, index) {
            const returnValue = insertRuleDescriptor.value.call(this, rule, index);
            if (this.ownerNode && !this.ownerNode.classList.contains('darkreader')) {
                this.ownerNode.dispatchEvent(updateSheetEvent);
            }
            return returnValue;
        }
        function proxyDeleteRule(index) {
            deleteRuleDescriptor.value.call(this, index);
            if (this.ownerNode && !this.ownerNode.classList.contains('darkreader')) {
                this.ownerNode.dispatchEvent(updateSheetEvent);
            }
        }
        function proxyRemoveRule(index) {
            removeRuleDescriptor.value.call(this, index);
            if (this.ownerNode && !this.ownerNode.classList.contains('darkreader')) {
                this.ownerNode.dispatchEvent(updateSheetEvent);
            }
        }
        function proxyDocumentStyleSheets() {
            const docSheets = documentStyleSheetsDescriptor.get.call(this);
            const filtered = [...docSheets].filter((styleSheet) => {
                return !styleSheet.ownerNode.classList.contains('darkreader');
            });
            return Object.setPrototypeOf(filtered, StyleSheetList.prototype);
        }
        Object.defineProperty(CSSStyleSheet.prototype, 'addRule', Object.assign({}, addRuleDescriptor, { value: proxyAddRule }));
        Object.defineProperty(CSSStyleSheet.prototype, 'insertRule', Object.assign({}, insertRuleDescriptor, { value: proxyInsertRule }));
        Object.defineProperty(CSSStyleSheet.prototype, 'deleteRule', Object.assign({}, deleteRuleDescriptor, { value: proxyDeleteRule }));
        Object.defineProperty(CSSStyleSheet.prototype, 'removeRule', Object.assign({}, removeRuleDescriptor, { value: proxyRemoveRule }));
        if (shouldWrapDocStyleSheets) {
            Object.defineProperty(Document.prototype, 'styleSheets', Object.assign({}, documentStyleSheetsDescriptor, { get: proxyDocumentStyleSheets }));
        }
    })()</script><style class="darkreader darkreader--user-agent" media="screen">html {
    background-color: #181a1b !important;
}
html, body, input, textarea, select, button {
    background-color: #181a1b;
}
html, body, input, textarea, select, button {
    border-color: #736b5e;
    color: #e8e6e3;
}
a {
    color: #3391ff;
}
table {
    border-color: #545b5e;
}
::placeholder {
    color: #b2aba1;
}
input:-webkit-autofill,
textarea:-webkit-autofill,
select:-webkit-autofill {
    background-color: #555b00 !important;
    color: #e8e6e3 !important;
}
::-webkit-scrollbar {
    background-color: #202324;
    color: #aba499;
}
::-webkit-scrollbar-thumb {
    background-color: #454a4d;
}
::-webkit-scrollbar-thumb:hover {
    background-color: #575e62;
}
::-webkit-scrollbar-thumb:active {
    background-color: #484e51;
}
::-webkit-scrollbar-corner {
    background-color: #181a1b;
}
* {
    scrollbar-color: #454a4d #202324;
}
::selection {
    background-color: #004daa !important;
    color: #e8e6e3 !important;
}
::-moz-selection {
    background-color: #004daa !important;
    color: #e8e6e3 !important;
}</style>
<meta charset="UTF-8">
<title>Offline Base64 Decoder</title>
<script type="text/javascript">
  function decodeBase64(textMode) {
    console.log("Text mode = " + textMode);
    var inbox = document.getElementById('base64input');
    var outbox = document.getElementById('output');
    var b64txt = inbox.value;
    var atext = base64Decode(b64txt, textMode);
    output.value = atext;
  }
  
  function base64Decode(encodedText, textMode) {
    console.log("Inbount b64 text has length = " + encodedText.length);
    var b64chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    var b0, b1, b2;
    var decodedText = "";
    
    // Remove any spaces.
    encodedText = encodedText.replace(/\s/g, "");
    
    if (encodedText.length % 4) {
      return "Error: Base64 encoded text must have a length divisable by 4; but length is " + encodedText.length;
    }
    
    if (/^[a-z0-9\+\/]+={0,2}$/i.test(encodedText)) {
      console.log("Encoded string passed validation.");
    } else {
      return "Error: Base64 encoded string has an invalid character.";
    }
    
    for (var p = 0; p < encodedText.length; p++) {
      var c = encodedText.charAt(p);
      if (c == '=') {
        // The '=' sign is a pad character.  Wrap things up depending
        // on how many pad characters there are.
        if (p % 2) {
          // There is one pad character; only add first two bytes and quit.
          decodedText += textMode ? String.fromCharCode(b0, b1) : b0.toString(16) + ' ' + b1.toString(16);
        } else {
          // There are two pad characters; only add first byte and quit.
          decodedText += textMode ? String.fromCharCode(b0) : b0.toString(16);
        }
        break;
      }
      var i = b64chars.indexOf(c);
      switch (p % 4) {
        case 0:
          // All 6 bits go to upper 6 bits of b0.
          b0 = i << 2;
          break;
        case 1:
          // Upper 2 bits fill in lower 2 bits of b0.
          // Lower 4 bits fill in upper 4 bits of b1.
          b0 = b0 | ((i & 0x0030) >>> 4);
          b1 = (i & 0x000f) << 4;
          break;
        case 2:
          // Upper 4 bits fill in lower 4 bits of b1.
          // Lower 2 bits fill in upper 2 bits of b2.
          b1 = b1 | ((i & 0x003c) >>> 2);
          b2 = (i & 0x0003) << 6;
          break;
        case 3:
          // All 6 bits fill lower 6 bits of b2.
          b2 = b2 | i;
          decodedText += textMode ? String.fromCharCode(b0, b1, b2) : b0.toString(16) + ' ' +
                                                                      b1.toString(16) + ' ' +
                                                                      b2.toString(16) + ' ';
          break;
      }
      if (!textMode &&  p % 16 == 0) {
        decodedText += '\n';
      }
    }
    return decodedText;
  }
</script>
<style type="text/css">
  body {
    background-color: #99cccc;
  }
  p {
    width: 550px;
    line-height: 1.3;
    font-family: Baskerville, "Palatino Linotype", Times, serif;
  }
</style><style class="darkreader darkreader--sync" media="screen"></style>
<meta name="darkreader" content="8e811a43d280e82675e9025f9e88e240"><style class="darkreader darkreader--override" media="screen">.vimvixen-hint {
    background-color: #7b5300 !important;
    border-color: #d8b013 !important;
    color: #f3e8c8 !important;
}
::placeholder {
    opacity: 0.5 !important;
}
a[href="https://coinmarketcap.com/"] > svg[width="94"][height="16"] > path {
    fill: var(--darkreader-neutral-text) !important;
}
#edge-translate-panel-body {
    color: var(--darkreader-neutral-text) !important;
}</style></head>
<body>
<h1>Offline Base64 Decoder</h1>
<p>
I developed this Base64 decoder because I needed a way to decode
information without sending it who-knows-where to some online decoder.
Don't forget that if you use Linux or OS X, you probably have the
<a href="https://www.openssl.org/docs/apps/enc.html#">openssl enc</a> 
and <strong>base64</strong> commands available to you.
</p>
<p>
This decoder is <strong>off-line</strong>.  It runs locally using 
JavaScript in your browser; 
<strong>not decoded remotely</strong>.  If you wish, you can save 
this HTML file locally and run it that way.
</p>
<textarea id="base64input" rows="8" cols="80" placeholder="Paste base64 text here"></textarea>
<br>
Base64 Decode 
<button onclick="decodeBase64(true)">to Text</button>
<button onclick="decodeBase64(false)">to Hex</button>
<br>
<textarea id="output" rows="45" cols="100"></textarea>


</body></html>